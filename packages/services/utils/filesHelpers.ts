// Generated by ts-to-zod
import fetch from 'node-fetch';
import { z } from 'zod';

import { NftFileData } from 'shared/types/wearableTypes';
import {
  EXTENSION_DESCRIPTIONS,
  EXTENSION_MIME_TYPES,
  FileExtension,
} from 'shared/utils/files';

import { logger } from './logger';

export const githubFileSchema = z.object({
  name: z.string(),
  path: z.string(),
  sha: z.string(),
  size: z.number(),
  url: z.string().url(),
  html_url: z.string().url(),
  git_url: z.string().url(),
  download_url: z.string().url(),
  type: z.string(),
  _links: z.object({
    self: z.string(),
    git: z.string(),
    html: z.string(),
  }),
});

export const githubContentsSchema = z.array(githubFileSchema);

const baseUrl =
  'https://api.github.com/repos/MetaFactoryAI/mf-wearables/contents/wearables';

export const getWearableFilesFromGithubForProduct = async (
  productId: string,
): Promise<NftFileData[]> => {
  const response = await fetch(`${baseUrl}/${productId}`, {
    headers: {
      Authorization: `Basic ${process.env.GITHUB_CREDENTIAL}`,
      'X-GitHub-Api-Version': '2022-11-28',
    },
  });

  try {
    const json: unknown = await response.json();
    const files = githubContentsSchema.parse(json);
    return files.map(formatFileMetadata);
  } catch (e) {
    logger.warn('Unable to get files from URL', {
      productId,
      error: e,
    });
    return [];
  }
};

export const formatFileMetadata = (
  data: z.infer<typeof githubContentsSchema.element>,
): NftFileData => {
  const fileExtension = /[^.]+$/.exec(data.name)?.[0] as FileExtension;
  if (!fileExtension) throw new Error('Invalid File Name');

  const mimeType = EXTENSION_MIME_TYPES[fileExtension];
  if (!mimeType) throw new Error('Unsupported file format');

  return {
    mimeType,
    name: data.name,
    uri: data.download_url,
    extension: fileExtension,
    properties: {
      description: EXTENSION_DESCRIPTIONS[fileExtension],
    },
  };
};
